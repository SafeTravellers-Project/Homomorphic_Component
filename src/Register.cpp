#include <cstddef>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <ctime>
#include <iomanip>
#include <time.h>

// SEAL
#include "seal/seal.h"

// TFHE
#include "tfhe.h"


#include "utils.h"
#include "dataIO.h"
#include "token.h"
#include "keysUser.h"

using namespace std;
using namespace seal;

inline void print_parameters(const seal::SEALContext &context)
{
    auto &context_data = *context.key_context_data();

    /*
    Which scheme are we using?
    */
    std::string scheme_name;
    switch (context_data.parms().scheme())
    {
    case seal::scheme_type::bfv:
        scheme_name = "BFV";
        break;
    case seal::scheme_type::ckks:
        scheme_name = "CKKS";
        break;
    case seal::scheme_type::bgv:
        scheme_name = "BGV";
        break;
    default:
        throw std::invalid_argument("unsupported scheme");
    }
    std::cout << "/" << std::endl;
    std::cout << "| Encryption parameters :" << std::endl;
    std::cout << "|   scheme: " << scheme_name << std::endl;
    std::cout << "|   poly_modulus_degree: " << context_data.parms().poly_modulus_degree() << std::endl;
    
    /*
    Print the size of the true (product) coefficient modulus.
    */
    std::cout << "|   coeff_modulus size: ";
    std::cout << context_data.total_coeff_modulus_bit_count() << " (";
    auto coeff_modulus = context_data.parms().coeff_modulus();
    std::size_t coeff_modulus_size = coeff_modulus.size();
    for (std::size_t i = 0; i < coeff_modulus_size - 1; i++)
    {
        std::cout << coeff_modulus[i].bit_count() << " + ";
    }

    std::cout << coeff_modulus.back().bit_count();
    std::cout << ") bits" << std::endl;
    for (std::size_t i = 0; i < coeff_modulus_size - 1; i++)
    {
        std::cout << coeff_modulus[i].value() << " + ";
    }
    //std::cout << "|   coeff_modulus: " << coeff_modulus << std::endl;

    /*
    For the BFV scheme print the plain_modulus parameter.
    */
    if (context_data.parms().scheme() == seal::scheme_type::bfv)
    {
        std::cout << "|   plain_modulus: " << context_data.parms().plain_modulus().value() << std::endl;
    }

    std::cout << "\\" << std::endl;
}
int main()
{
  //UserID::generateID(); We either use this ID or the ID generated by the SSI wallet. 
  UserKeyGen::generateUserKeys();
  


  // Read the SEAL parameters from the file

 std::ifstream bin_sealparam_handler("../data/System Parameters/sealparam.txt", std::ios::in | std::ios::binary);
    if (!bin_sealparam_handler) {
        std::cerr << "Seal param file did not open!" << std::endl;
        return 1;
    }

   // Read the parameters from the file
    EncryptionParameters parms(scheme_type::bfv);
    //bin_sealparam_handler.read(reinterpret_cast<char*>(&parms), sizeof(EncryptionParameters));
    parms.load(bin_sealparam_handler);
    bin_sealparam_handler.close();

    if (!bin_sealparam_handler.good()) {
        std::cerr << "Error occurred during reading the seal param binary file!" << std::endl;
        return 2;
    }

SEALContext context(parms);
//print_parameters(context);

// Now copying the necessary keys

PublicKey init_public_key;
  //std::ifstream bin_sealpubK_INhandler;
  filebuf bin_sealpubK_handler;
  if (bin_sealpubK_handler.open("../data/Traveller/sealpubK.txt", ios::in | ios::binary))
    { //std::cout << "In here" << '\n';
    istream is(&bin_sealpubK_handler);
    init_public_key.load(context,is);
    bin_sealpubK_handler.close();}

SecretKey init_seal_key;
filebuf bin_sealpvtK_handler;
  bin_sealpvtK_handler.open("../data/Traveller/sealpvtK.txt", ios::in | ios::binary);
   istream is2(&bin_sealpvtK_handler);
    init_seal_key.load(context,is2);
  //bin_sealpvtK_handler.write((char *) &init_seal_key, sizeof(SecretKey));
  bin_sealpvtK_handler.close();    

//cout << "Keys copied successfully" << endl;

// Encryption/Decryption/Encoding structures in SEAL
Encryptor init_encryptor(context, init_public_key);
//cout << "Encryptor created" << endl;

//Some necesary parameters for the Biometrics
const int N = parms.poly_modulus_degree();
//cout << "Value of N: " << N << endl;
const uint64_t p = parms.plain_modulus().value();
const int precision = 3;
const int vector_size = 1024;
  if (vector_size > N)
  {
    std::cout << "The size of N has to be greater than that of the Biometrics vectors" << '\n';
    return -1;
  }

  /**
  * Read the initial Plaintext models, i.e. the embeddings of the biometrics as SEAL Plaintexts
  */
 
  Plaintext model; // The embeddings as SEAL plaintext polynomials stored in an array of models
  Plaintext modelSquare; 
  Plaintext modelCos;

  Ciphertext modelSEALCipher; 
  Ciphertext modelSEALCipherSquare; 
  Ciphertext modelSEALCosineCipher;

  cout << "Reading the Biometrics..." << endl;
  clock_t read_bio_start = clock();
  std::string fileName_model = "../data/Traveller/Reg_Biometrics";
  dataIO::readPlaintext(&model, fileName_model, vector_size, precision, p, 0);  
  dataIO::readPlaintextSquare(&modelSquare, fileName_model, vector_size, precision, p);
  dataIO::readPlaintextCosine(&modelCos, fileName_model, vector_size, precision, p,0);
clock_t read_bio_end = clock();

  cout << "Encrypting and registering the Biometrics..." << endl;
  clock_t enc_bio_start = clock();
  init_encryptor.encrypt(model, modelSEALCipher);
  init_encryptor.encrypt(modelSquare, modelSEALCipherSquare);
  init_encryptor.encrypt(modelCos, modelSEALCosineCipher);

//  TokenGenerator tokenGen;
//  std::string token = tokenGen.generateToken(Reg_name, init_seal_key);  //maybe need to change as we do not use the init_public key but trather the secret key, but this does not ave to be the secret key persay.

//Explicitly destroying the seal pvt key in-order to avoid any memory leaks
  init_seal_key.data().set_zero();
//Also we need to add this token to the database, so that we can use it later to verify the user. This must be added to the first line and can be just called to verify. 


//Writing the ciphertexts to file
filebuf bin_sealmodelciph_handler;
bin_sealmodelciph_handler.open("../data/CountryDB/modelciph.txt", std::ios::out | ios::binary);
 if (!bin_sealmodelciph_handler.is_open()) {
     std::cerr << "Error opening file for writing model cipher!" << std::endl;
     return 1;
 }
std::ostream os(&bin_sealmodelciph_handler);
// Write modelSEALCipher data
modelSEALCipher.save(os);
// Write modelSEALCipherSquare data
//modelSEALCipherSquare.save(os);

bin_sealmodelciph_handler.close();

filebuf bin_sealmodelsqciph_handler;
bin_sealmodelsqciph_handler.open("../data/CountryDB/modelsqciph.txt", std::ios::out | ios::binary);
 if (!bin_sealmodelsqciph_handler.is_open()) {
     std::cerr << "Error opening file for writing model cipher sq!" << std::endl;
     return 1;
 }
std::ostream os2(&bin_sealmodelsqciph_handler);
// Write modelSEALCipherSquare data
modelSEALCipherSquare.save(os2);

bin_sealmodelsqciph_handler.close();

filebuf bin_sealmodelcosineciph_handler;
bin_sealmodelcosineciph_handler.open("../data/CountryDB/modelcosineciph.txt", std::ios::out | ios::binary);
 if (!bin_sealmodelcosineciph_handler.is_open()) {
     std::cerr << "Error opening file for writing model cipher sq!" << std::endl;
     return 1;
 }
std::ostream os3(&bin_sealmodelcosineciph_handler);
// Write modelSEALCipherSquare data
modelSEALCosineCipher.save(os3);

bin_sealmodelcosineciph_handler.close();

clock_t enc_bio_end = clock();



cout << "***************************************************" << endl;
cout << "*     Successfully Registered User Biometrics     *" << endl;
cout << "***************************************************" << endl;
double read_bio_time = double(read_bio_end - read_bio_start) / CLOCKS_PER_SEC;
double enc_bio_time = double(enc_bio_end - enc_bio_start) / CLOCKS_PER_SEC;
cout << "Time for reading the Biometrics: " << read_bio_time << " seconds" << endl;
cout << "Time for encrypting and registering the Biometrics: " << enc_bio_time << " seconds" << endl;

/*
  tmr.reset();
  filebuf bin_sealcosciph_handler;
  bin_sealcosciph_handler.open("../data/CountryDB/cosciph.txt", ios::out | ios::binary);
    ostream os3(&bin_sealcosciph_handler);
    for(int i =0; i <d; i++){
      CosineSEALCipher[i].save(os3);}
  //bin_sealpubK_handler.write((char *) &init_public_key, sizeof(PublicKey));
  bin_sealcosciph_handler.close();
*/
  return 0;
}